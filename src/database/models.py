"""
Data models for the Task Management System.
Defines the structure and validation for data objects.
"""
from datetime import datetime
from typing import Dict, List, Optional, Any, Union
from enum import Enum

class TaskStatus(str, Enum):
    """Enum for task status values."""
    ACTIVE = 'active'
    COMPLETED = 'completed'
    DELETED = 'deleted'

class PromptStatus(str, Enum):
    """Enum for AI prompt status values."""
    ACTIVE = 'active'
    INACTIVE = 'inactive'

class Task:
    """Task data model."""
    
    def __init__(
        self,
        id: Optional[str] = None,
        user_id: str = None,
        title: str = None,
        description: str = None,
        due_date: Optional[datetime] = None,
        status: str = TaskStatus.ACTIVE,
        created_at: Optional[datetime] = None,
        updated_at: Optional[datetime] = None,
        completion_date: Optional[datetime] = None,
        deletion_date: Optional[datetime] = None,
        notes: str = None,
        updates: List[Dict[str, Any]] = None
    ):
        """
        Initialize a Task object.
        
        Args:
            id: Unique task identifier (auto-generated by Firestore)
            user_id: Owner identifier
            title: Task title
            description: Task description (optional)
            due_date: Task due date (optional)
            status: Task status (active, completed, deleted)
            created_at: Creation timestamp
            updated_at: Last update timestamp
            completion_date: When task was completed
            deletion_date: When task was deleted
            notes: Additional user notes
            updates: History of changes
        """
        self.id = id
        self.user_id = user_id
        self.title = title
        self.description = description
        self.due_date = due_date
        self.status = status
        self.created_at = created_at
        self.updated_at = updated_at
        self.completion_date = completion_date
        self.deletion_date = deletion_date
        self.notes = notes
        self.updates = updates or []
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Task':
        """
        Create a Task object from a dictionary.
        
        Args:
            data: Dictionary containing task data
            
        Returns:
            Task object
        """
        return cls(
            id=data.get('id'),
            user_id=data.get('userId'),
            title=data.get('title'),
            description=data.get('description'),
            due_date=data.get('dueDate'),
            status=data.get('status', TaskStatus.ACTIVE),
            created_at=data.get('createdAt'),
            updated_at=data.get('updatedAt'),
            completion_date=data.get('completionDate'),
            deletion_date=data.get('deletionDate'),
            notes=data.get('notes'),
            updates=data.get('updates', [])
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert Task object to a dictionary.
        
        Returns:
            Dictionary representation of the task
        """
        data = {
            'userId': self.user_id,
            'title': self.title,
            'status': self.status
        }
        
        # Add optional fields if they exist
        if self.id:
            data['id'] = self.id
        if self.description:
            data['description'] = self.description
        if self.due_date:
            data['dueDate'] = self.due_date
        if self.completion_date:
            data['completionDate'] = self.completion_date
        if self.deletion_date:
            data['deletionDate'] = self.deletion_date
        if self.notes:
            data['notes'] = self.notes
        if self.updates:
            data['updates'] = self.updates
            
        # Don't include created_at and updated_at as they're handled by Firestore
        
        return data
    
    def validate(self) -> bool:
        """
        Validate the task data.
        
        Returns:
            True if valid, False otherwise
        
        Raises:
            ValueError: If validation fails
        """
        if not self.user_id:
            raise ValueError("User ID is required")
        if not self.title:
            raise ValueError("Title is required")
        if self.status not in [s.value for s in TaskStatus]:
            raise ValueError(f"Invalid status: {self.status}")
        
        return True

class AIChat:
    """AI Chat data model."""
    
    def __init__(
        self,
        id: Optional[str] = None,
        user_id: str = None,
        input_text: str = None,
        created_at: Optional[datetime] = None,
        updated_at: Optional[datetime] = None,
        response: Optional[str] = None,
        feedback_rating: Optional[str] = None,
        feedback_text: Optional[str] = None
    ):
        """
        Initialize an AIChat object.
        
        Args:
            id: Unique chat identifier (auto-generated by Firestore)
            user_id: User identifier
            input_text: User input text
            created_at: Creation timestamp
            updated_at: Last update timestamp
            response: AI-generated response
            feedback_rating: Thumbs up or down from the user (optional)
            feedback_text: Additional feedback text (optional)
        """
        self.id = id
        self.user_id = user_id
        self.input_text = input_text
        self.created_at = created_at
        self.updated_at = updated_at
        self.response = response
        self.feedback_rating = feedback_rating
        self.feedback_text = feedback_text
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AIChat':
        """
        Create an AIChat object from a dictionary.
        
        Args:
            data: Dictionary containing chat data
            
        Returns:
            AIChat object
        """
        return cls(
            id=data.get('id'),
            user_id=data.get('user_id'),
            input_text=data.get('inputText'),
            created_at=data.get('createdAt'),
            updated_at=data.get('updated_at'),
            response=data.get('Response'),
            feedback_rating=data.get('feedbackRating'),
            feedback_text=data.get('feedbackText')
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert AIChat object to a dictionary.
        
        Returns:
            Dictionary representation of the chat
        """
        data = {
            'user_id': self.user_id,
            'inputText': self.input_text
        }

        # Add response if it exists
        if self.response:
            data['Response'] = self.response

        if self.feedback_rating is not None:
            data['feedbackRating'] = self.feedback_rating
        if self.feedback_text is not None:
            data['feedbackText'] = self.feedback_text

        # Don't include created_at and updated_at as they're handled by Firestore

        return data
    
    def validate(self) -> bool:
        """
        Validate the chat data.
        
        Returns:
            True if valid, False otherwise
        
        Raises:
            ValueError: If validation fails
        """
        if not self.user_id:
            raise ValueError("User ID is required")
        if not self.input_text:
            raise ValueError("Input text is required")
        
        return True

class AIPrompt:
    """AI Prompt data model."""
    
    def __init__(
        self,
        id: Optional[str] = None,
        prompt_name: str = None,
        text: str = None,
        status: str = PromptStatus.ACTIVE,
        version: int = 1
    ):
        """
        Initialize an AIPrompt object.
        
        Args:
            id: Unique prompt identifier (auto-generated by Firestore)
            prompt_name: Name of the prompt
            text: Prompt text
            status: Prompt status (active, inactive)
        """
        self.id = id
        self.prompt_name = prompt_name
        self.text = text
        self.status = status
        self.version = version
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AIPrompt':
        """
        Create an AIPrompt object from a dictionary.
        
        Args:
            data: Dictionary containing prompt data
            
        Returns:
            AIPrompt object
        """
        return cls(
            id=data.get('id'),
            prompt_name=data.get('prompt_name'),
            text=data.get('text'),
            status=data.get('status', PromptStatus.ACTIVE),
            version=data.get('version', 1)
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert AIPrompt object to a dictionary.
        
        Returns:
            Dictionary representation of the prompt
        """
        return {
            'prompt_name': self.prompt_name,
            'text': self.text,
            'status': self.status,
            'version': self.version
        }
    
    def validate(self) -> bool:
        """
        Validate the prompt data.
        
        Returns:
            True if valid, False otherwise
        
        Raises:
            ValueError: If validation fails
        """
        if not self.prompt_name:
            raise ValueError("Prompt name is required")
        if not self.text:
            raise ValueError("Prompt text is required")
        if self.status not in [s.value for s in PromptStatus]:
            raise ValueError(f"Invalid status: {self.status}")
        if self.version < 1:
            raise ValueError("Version must be >= 1")

        return True


class EvalStatus(str, Enum):
    """Enum for evaluation input status values."""

    ACTIVE = 'active'
    ARCHIVED = 'archived'


class AIEvalInput:
    """AI Evaluation Input data model."""

    def __init__(
        self,
        id: Optional[str] = None,
        user_id: str = None,
        input_text: str = None,
        response: Optional[str] = None,
        status: str = EvalStatus.ACTIVE,
        created_at: Optional[datetime] = None,
        updated_at: Optional[datetime] = None,
    ):
        self.id = id
        self.user_id = user_id
        self.input_text = input_text
        self.response = response
        self.status = status
        self.created_at = created_at
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AIEvalInput":
        return cls(
            id=data.get('id'),
            user_id=data.get('user_id'),
            input_text=data.get('inputText'),
            response=data.get('Response'),
            status=data.get('status', EvalStatus.ACTIVE),
            created_at=data.get('createdAt'),
            updated_at=data.get('updatedAt'),
        )

    def to_dict(self) -> Dict[str, Any]:
        data = {
            'user_id': self.user_id,
            'inputText': self.input_text,
            'status': self.status,
        }
        if self.response is not None:
            data['Response'] = self.response
        return data

    def validate(self) -> bool:
        if not self.user_id:
            raise ValueError('User ID is required')
        if not self.input_text:
            raise ValueError('Input text is required')
        if self.status not in [s.value for s in EvalStatus]:
            raise ValueError(f'Invalid status: {self.status}')
        return True
